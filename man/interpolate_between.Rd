% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpolate.R
\name{interpolate_between}
\alias{interpolate_between}
\title{Interpolate equidistantly between End Points}
\usage{
interpolate_between(y1, y2, n = 2L, version = 3)
}
\arguments{
\item{y1}{numeric vector of y-values at the beginning}

\item{y2}{numeric vector of y-values at the end. Must be as long as \code{y1}}

\item{n}{number of interpolation points including first and last value}

\item{version}{version of implementation}
}
\value{
matrix \code{M} with \code{n} columns and as many rows as there are
  values in \code{y1} (and also in \code{y1}). The first column contains the
  values from \code{y1}, the last column contains the values from \code{y2}
  and the \code{n - 2} columns in between contain the interpolated values.
}
\description{
Interpolate equidistantly between End Points
}
\examples{
y1 <- c(1, 1, 1)
y2 <- c(0.1, 0.5, 0.8)
n <- 10

y <- interpolate_between(y1, y2, n)
barplot(y, beside = TRUE)

# Compare the performance of slightly different implementations
microbenchmark::microbenchmark(
  v1 = interpolate_between(y1, y2, n, version = 1),
  v2 = interpolate_between(y1, y2, n, version = 2),
  v3 = interpolate_between(y1, y2, n, version = 3),
  times = 1000,
  check = function(x) kwb.utils::allAreIdentical(x[2:3]) &&
    all(kwb.utils::almostEqual(x[[1]], x[[2]]))
)

}
